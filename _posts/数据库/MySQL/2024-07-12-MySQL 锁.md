---
layout: mypost
title: MySQL 锁
categories: [ MySQL ]
---

# 表级锁和行级锁

- 表级锁：MySQL中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。
  不过除非锁冲突的概率最高，高并发下效率极低。表级锁与存储引擎无关，MyISAM,InnoDB引擎都支持表级锁。
- 行级锁：MySQL中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
  行级锁和存储引擎有关，是在存储引擎层面实现的。

# InnoDB有哪几类锁

- 记录锁（Record Lock）：属于单个行记录上的锁
- 间隙锁（Gap Lock）: 锁定一个范围，不包括记录本身。
- 临键锁（Next-Key Lock）: Record Lock + Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。

# 共享锁和排他锁

- 共享锁（S锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
- 排他锁（X锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能在对这条记录加任何类型的锁。

# 意向锁

如果要用到表锁的话，如何判断表中的记录没有行锁，一行行遍历肯定不行，性能太差。我们需要用到一个叫意向锁的东西来快速判断是否可以对某个表使用表锁。

- 意向共享锁（IS锁）：事务有意向对表中的某些记录加共享锁（S锁），加共享锁前必须先获得该表的IS锁。
- 意向排他锁（IX锁）：事务有意向对表中的某些记录加排他锁（X锁），加排他锁前必须先获得该表的IX锁。

**意向锁是有数据引擎自己维护的，用户无法收到操作意向锁，在为数据行加共享/排他锁之前，InnoDB会先获取该数据行所在数据表的对应意向锁。**

