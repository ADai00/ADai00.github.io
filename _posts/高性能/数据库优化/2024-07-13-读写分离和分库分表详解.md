---
layout: mypost
title: 读写分离和分库分表详解
categories: [ 高性能 ]
---

# 读写分离

## 什么是读写分离

读写分离主要是将数据库的读写操作分散到不同的数据节点上。这样的话，能够小幅提升写性能，大幅提升读性能。

![img.png](img.png)

一般情况下，都会选择一主多从，一台主数据库负责写，其他从数据库负责读。主库和从库直接会进行数据同步，以保证从库中数据的准确性。

## 如何实现读写分离

- 部署多台数据库，选择其中一台作为主数据库，其他的一台或者多台作为从数据库。
- 保证主数据库和从数据直接的数据是实时同步的，这个过程就是**主从复制**。
- 系统将写请求交给主数据库处理，读请求交给从数据库处理。

落实到项目本身，常用的方式有两种：

### 1.代理方式

![img_1,png](img_1.png)

在应用和数据中间加一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。

提供类似功能的中间件有 **MySQL Router**(官方),Atlas,MaxScale,MaCat。

### 2.组件方式

通过引入第三方组件来帮助我们读写请求，推荐使用 sharding-jdbc,直接引入jar包即可使用。

## 主从复制原理

![img_2,png](img_2.png)

1. 主库将数据库中数据的变化写入到binlog
2. 从库连接到主库
3. 从库创建一个I/O线程向主库请求更新的binlog
4. 主库创建一个binlog dump线程来发送binlog，从库中I/O线程负责接收
5. 从库的I/O线程将接收的binlog写入到relay log中
6. 从库的SQL线程读取relay log同步数据到本地

## 如何避免主从延迟？

### 强制将读请求路由到主库处理

将接口进行分类，那些必须获取最新数据的读请求都交给主库处理。

### 延迟读取

完成写请求后，避免立即进行请求操作，可以先跳转一个成功页面进行过度。

## 什么情况下会出现主从延迟?如何尽量减少延迟？

与主从同步有关的时间点主要有3个：

1. 主库执行完一个事务，写入binlog，将这个时刻记为T1
2. 从库I/O线程接收到binlog并写入relay log的时刻记为T2
3. 从库SQL线程读取relay log同步数据到本地的时刻记为T3

结合我们上面讲到的主从复制原理，可以得出：

- T2 和 T1 的差值反映了从库 I/O 线程的性能和网络传输的效率，这个差值越小说明从库 I/O 线程的性能和网络传输效率越高。
- T3 和 T2 的差值反映了从库 SQL 线程执行的速度，这个差值越小，说明从库 SQL 线程执行速度越快。

那什么情况下会出现出从延迟呢？这里列举几种常见的情况：

1. 从库机器性能比主库差
2. 从库处理的读请求过多
3. 大事务
4. 从库太多
5. 网络延迟

# 分库分表

## 什么是分库

分库 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。

垂直分库 就是把单一数据库安装业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。

![img_3,png](img_3.png)

水平分库 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上。

![img_4,png](img_4.png)

## 什么是分表

分表 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。

垂直分表 是对数据表列的拆分，把一张列比较多的表拆分为多张表。

举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。

水平分表 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。

举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，水平分表通常和水平分库同时出现。

![img_5,png](img_5.png)

## 什么情况下需要分库分表

- 单表的数据达到千万级别以上，数据读写速度比较缓慢。
- 数据中的数据占用的空间越来越大，备份时间越来越长。

分库分表的成本太高，如非必要尽量不要采用。而且，并不一定是单表千万级数据量就要分表，毕竟每张表包含的字段不同，它们在不错的性能下能够存放的数据量也不同，还是要具体情况具体分析。

## 常见的分片算法

- 哈希分片：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩（例如新增一个表或者库）不友好。
- 范围分片：按照特定的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 id 为 1~299999 的记录分到第一个表，300000~
  599999的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。
- 映射表分片：使用一个单独的表（称为映射表）来存储分片键和分片位置的对应关系。映射表分片策略可以支持任何类型的分片算法，如哈希分片、范围分片等。映射表分片策略是可以灵活地调整分片规则
  ，不需要修改应用程序代码或重新分布数据。不过，这种方式需要维护额外的表，还增加了查询的开销和复杂度。
- 一致性哈希分片：将哈希空间组织成一个环形结构，将分片键和节点（数据库或表）都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。
- 地理位置分片：很多NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。
- 融合算法分片：灵活组合多种分片算法，比如将哈希分片和范围分片组合。

## 分库分表带来的问题

- join操作
- 事务问题
- 分布式ID
- 跨库聚合查询问题

## 分库分表后，数据怎么迁移

- 停机迁移：写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计1小时。然后，你写一个脚本将老库的数据都同步到新库中。
- 双写方案：
    - 对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。
    - 在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）
    - 重复上一步的操作，直到老库和新库的数据一致为止。